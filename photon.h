#ifndef PHOTON_H
#define PHOTON_H

/*******************************
********** How to use **********
1) 

*********** Inputs *************
1) Spacetime grid: 
* text file: 5 floats per line (temperature, QGP fraction, ux/u0, uy/u0, uz/u0)
* binary file: blocks of 5 floats
* the spacetime position of the cell is given by the line
2) Shear grid:



*********************************/

//Libraries
#include <string>
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <sstream>
#include <fstream>

//Read parameters directly from a file generated by the hydro
#include "hydro_info_header_h"


/********* Inputs ********/
//Format of the input files
const bool CONST_binaryMode=MUSIC_outputBinaryEvolution; //0 for text, 1 for binary
//Location of the spacetime grid file
const std::string stGridFile="./evolution_xyeta.dat";
//const std::string stGridFile="./evolution_test.dat";

//Information about the spacetime grid
//Number of cells of the grid
const int cellNb_x=MUSIC_real_nx;
const int cellNb_y=MUSIC_real_ny;
const int cellNb_eta=MUSIC_real_neta;
//Size of the cells
const double CONST_cellsize_X=MUSIC_dx; //In fm
const double CONST_cellsize_Y=MUSIC_dy; //In fm
const double CONST_cellsize_Eta=MUSIC_deta; //In units of rapidity
//Initial time tau_0
const double CONST_tau0=MUSIC_tau0;
const double CONST_effective_dTau=MUSIC_effective_dtau;

//Run with viscosity or not
const bool CONST_with_shear_viscosity=MUSIC_with_shear_viscosity; //0 for thermal, 1 for anisotropic
const bool CONST_with_viscosity=CONST_with_shear_viscosity;
//const double shear_to_s=0.08;
//Location of the viscous files
const std::string viscosityFile="evolution_Wmunu_over_epsilon_plus_P_xyeta.dat";

//Discretization of photon spectrum
//kT
const double CONST_ktMin=0.2; //Minimum value for kT
const double CONST_ktMax=4.0; //Maximum value for kT
const int CONST_Nkt=20;  //Warning: delta kT=(ktMax-kTmin)/(Nkt-1) 
//const double kTdisc[3] = [0.2,4.0,0.2] //Discretization in kT: [kT min, kT max, delta kT]
const int CONST_Nphi=16;  //phi
//Rapidity
const double CONST_etaMin=-0.0; //Minimum value for eta
const double CONST_etaMax=0.0; //Maximum value for eta
const int CONST_Neta=1;  //Warning: delta eta=(etaMax-etamin)/(Nkt-1)

//Deltas used for the (uniform) discretization of the grid
const double CONST_delEta= CONST_Neta > 1 ? (CONST_etaMax-CONST_etaMin)/(CONST_Neta-1.0) : 0;
const double CONST_delPhi=(2*M_PI)/(CONST_Nphi-1.0);
const double CONST_delKt=(CONST_ktMax-CONST_ktMin)/(CONST_Nkt-1.0);

//Observables
//const std::vector<std::string> CONST_rateList = {"ideal","viscous","viscousDusling"};
//const int miaw[] = {1,2,3,4};
//const char char_rateList[4][100] = {"01", "02", "03", "04"};
//std::vector<std::string> v(char_rateList, char_rateList + 4);
/*
Rates:
1: double rate_qgp_ideal_born_AMYfit(double kOverT, double T, double kkPiOver_e_P_k2);
2: double rate_qgp_ideal_born_KLS(double kOverT, double T, double kkPiOver_e_P_k2);
3: double rate_qgp_ideal_born_JF_sqrtg(double kOverT, double T, double kkPiOver_e_P_k2);
4: double rate_qgp_viscous_only_born_JF_sqrtg(double kOverT, double T, double kkPiOver_e_P_k2);
*/
const int CONST_rates_to_use[] = {1,2,3,4,5};
const int CONST_N_rates = sizeof(CONST_rates_to_use)/sizeof(int);
//
const char char_standard_rateList[][100] = {"rate_qgp_ideal_born_AMYfit","rate_qgp_ideal_born_KLS","rate_qgp_ideal_born_JF_sqrtg","rate_qgp_viscous_only_born_JF_sqrtg","rate_hg_ideal_Turbide_fit"};
const int CONST_N_standard_rates=int(sizeof(char_standard_rateList)/sizeof(char)/100.);
const std::vector<std::string> CONST_rate_names(char_standard_rateList, char_standard_rateList + CONST_N_standard_rates);


//Mid-rapidity cut: the midrapidity result will be an average over approximatively -midRapCut to midRapCut
const double CONST_midRapCut = 0.5;
//Number of Fourier coefficient to compute
const int CONST_FourierNb = 2;

//QGP fraction definition
const double CONST_pure_QGP_T=0.22;	
const double CONST_pure_HG_T=0.184;	
const double CONST_freezeout_T=MUSIC_kinetic_FO_temperature_in_GeV;

//Generate spectra sums from t0 to t_i with t_i \in CONST_tauList
//const double CONST_tauList[]={.6,1.0,2.0};
//const double CONST_tempList[]={.180,.500};

//General constants
const int CONST_Nc=3;
const int CONST_Nf=3;
const double CONST_CF=(CONST_Nc*CONST_Nc-1.0)/(2.0*CONST_Nc);
const double CONST_alphaEM=1/137.0;
const double CONST_alphaS=0.3;
const double CONST_gs=sqrt(4*M_PI*CONST_alphaS);
const double CONST_mInfOverT=sqrt(CONST_CF)*CONST_gs/2.0;
const double CONST_twoPiCubed=pow(2*M_PI,3);

/*************************/

//Use to store spacetime position and related informations
struct phaseSpace_pos {

	//
	double tau, x, y, eta;

	//
	int ikt, ieta, iphi;

	//
	int iTauList;
	bool newiTau;

};

#endif
